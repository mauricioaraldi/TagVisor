Introduction

TagVisor is a choreographer for events of animation and page modification in HTML5. It reads instructions, rules, and dispatch operations, such as animations, in a given HTML page, and its children objects, for example  iframes. This library is highly experimental -- use it at your own risk. TagVisor can be used to create live animated experiences for web pages.

Exploration and Paradigm: 
For  a given document, there is a stack of handlers, and these can dispatch a  new event in the DOM tree if certain conditions associated with the  input event values that each of these handlers receives. As an example  of a use case, imagine a voting system web page with many input fields.  Each input field stores a numeric value and for each of them, there is  an event handler. So, for every value mutation in any given field, a  class event is generated. This class event can be watched by another  event handler that can check if a given criterial is met, for example,  the sum of all the input fields to be greater than value X. Another case  is simply generating another event that has the current sum of all the  input values. 
Proposed features: 

* Animation and Special Effects for Web Pages
* Develops the Concept of Stream-driven events to Govern Browsing Session
* Focuses in Time and Animation
* Events Model for Mutation 
* Iframes support 
* DOM Mutation Templates support 
* History and User-based Control to Modify Content
* DOM Node to JS Object Reflection ( Core ) 



Event manager. 

The event manager is responsible for watching incoming events in a document tree. It uses the event name and data to find if there is a registered handler, in our case, this is defined by a a selector.  When it finds this handler, it should execute the handler's function, which may generate other events. Each event has an unique ID and once processed, they are to be moved to a a data store that represents the history of events. 

We can also have more than one event to trigger a handler. This operation is a composition
or a compound event - if you think that a new event will be result of multiple incoming 
events. So, for example, here is one way to implement this:

* * * { 
	kick marcio:one; 
}  

clock { 
	kick marcio:two; 
} 

marcio { 
	in: one & two; 
	out: marcio2
} 

Issues with selectors 

	Wildcard: in order to make the wild card for ranges of values 
	you would need to generate a lot of selectors to the whole range
 	of possibilities. 


Cases

	Main rule for events that can apply to elements ( widgets ) amonng 
	all iframes including nested iframes. 


	* * 20 load iframe clock

	* * 25 #clock zoom 
		internal ( scale ) - insertRule

	* * 30 remove clock 

Cases

 	For each second, we kick a time stamp event
  	if someone wants to add something to the current t+1
	you insert a rule for the t+1. 

	Case, a 30 seconds animation that has t=1 E=1 t=10,E2 and t=20, E3
	and repeats.

	* * 1 E1
	* * 10 E2 
	* * 20 E3 
 	
	time[secs=1] { E1 } time[secs=10] { E2 } time[secs=20] { E3 } 

	Each time event that happens in the timeline DOM storage appears and 
	goes away, to a history DOM storage, which means processed. 


DailyCron 
 
  A heart beat loop ticker system that queries a 
  data set of rules and applies ( generate events ) 
 
  Temporal Selectors
  
  Date, 
  Time, 

  time[date="20/08/2011"] { 
     apply-event: 
  } 

  time[cron="* * *"] { 
     apply-event: 
  } 

===

* Insert time-based event at any time
* Delete time-based events 

Mutation Events

  + Iframe creation ( compatible widget ) 
  + Iframe destruction ( compatible widget ) 
  + DOM manipulation
  + CSS rule insertion / removal 


